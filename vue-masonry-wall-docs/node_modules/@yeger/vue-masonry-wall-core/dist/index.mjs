function _({
  columns: v,
  columnWidth: l,
  emit: d,
  gap: g,
  items: w,
  maxColumns: o,
  minColumns: i,
  nextTick: M,
  onBeforeUnmount: k,
  onMounted: Y,
  rtl: y,
  scrollContainer: h,
  ssrColumns: s,
  vue: D,
  wall: f,
  watch: p
}) {
  function R(t, e, r, u) {
    const a = T(r);
    return u + e + a <= t ? R(
      t,
      e,
      r + 1,
      u + e + a
    ) : r;
  }
  function T(t) {
    const e = Array.isArray(l.value) ? l.value : [l.value];
    return e[t % e.length];
  }
  function b() {
    const t = R(
      f.value.getBoundingClientRect().width,
      g.value,
      0,
      // Needs to be offset my negative gap to prevent gap counts being off by one
      -g.value
    ), e = S(E(t));
    return e > 0 ? e : 1;
  }
  function E(t) {
    const e = o == null ? void 0 : o.value;
    return e && t > e ? e : t;
  }
  function S(t) {
    const e = i == null ? void 0 : i.value;
    return e && t < e ? e : t;
  }
  function B(t) {
    return Array.from({ length: t }).map(() => []);
  }
  if (s.value > 0) {
    const t = B(s.value);
    w.value.forEach(
      (e, r) => t[r % s.value].push(r)
    ), v.value = t;
  }
  async function A(t) {
    if (t >= w.value.length)
      return;
    await M();
    const e = [...f.value.children];
    y.value && e.reverse();
    const r = e.reduce(
      (u, a) => a.getBoundingClientRect().height < u.getBoundingClientRect().height ? a : u
    );
    v.value[+r.dataset.index].push(t), await A(t + 1);
  }
  async function c(t = !1) {
    if (v.value.length === b() && !t) {
      d(D === 2 ? "redraw-skip" : "redrawSkip");
      return;
    }
    v.value = B(b());
    const e = h == null ? void 0 : h.value, r = e ? e.scrollTop : window.scrollY;
    await A(0), e ? e.scrollBy({ top: r - e.scrollTop }) : window.scrollTo({ top: r }), d("redraw");
  }
  const n = typeof ResizeObserver > "u" ? void 0 : new ResizeObserver(() => c());
  return Y(() => {
    c(), n == null || n.observe(f.value);
  }), k(() => n == null ? void 0 : n.unobserve(f.value)), p([w, y], () => c(!0)), p([l, g, i, o], () => c()), { getColumnWidthTarget: T };
}
export {
  _ as useMasonryWall
};
